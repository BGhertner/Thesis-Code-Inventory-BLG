MODULE init3d_blg_module

implicit none

private
public :: linearshear_mode, inversionwave, cldoverclear_wave

CONTAINS

!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!cc  Start definition of initial perturbation (iinit option)  ccccc
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

!-----------------------------------------------------------------------------
!
!  subroutine inversionwave: perturbation for the inversion wave.
!
!  &param8 inputs :
!            var14 : horizontal (x-direction) wave number [rad/m]
!            var15 : horizontal (y-direction) wave number [rad/m]
!            var16 : wave speed initial guess [m/s]
!            var17 : wave amplitude
!
!       inputs from base (isnd=1300)
!            var1  : surface pressure [Pa]
!            var2  : surface temperature [K]
!            var3  : N^2 in the inversion layer [1/s^2] (before water pert.)
!            var4  : N^2 in the troposphere [1/s^2] (before water pert.)
!            var5  : inversion height [m]
!            var6  : fog top height [m]
!
!  NOTES: BLG 10 Jun 2025
!        - Wave speed and eigenmode is generated by an interal nonlinear solve.
!        - Setting var15 = 0 does the 2D case
!        - 3D wave traveling in the x-direction
!
!-----------------------------------------------------------------------------

subroutine inversionwave(xh,xf,yh,yf,zh,zf,pi0,prs0,th0,thl0,&
                            qv0,qc0,rst0,u0,v0,ua,va,wa,tha,qa)

    use input
    use constants
    use cm1libs , only : rslf
    use bc_module

    implicit none

    real, dimension(ib:ie) :: xh
    real, dimension(ib:ie+1) :: xf
    real, dimension(jb:je) :: yh
    real, dimension(jb:je+1) :: yf
    real, dimension(ib:ie,jb:je,kb:ke) :: zh
    real, dimension(ib:ie,jb:je,kb:ke+1) :: zf
    real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,th0,qv0,qc0,t0,thl0,rst0
    real, dimension(ib:ie,jb:je,kb:ke) :: tha
    real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
    real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua
    real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va
    real, dimension(ib:ie,jb:je,kb:ke+1) :: wa

    integer :: i,j,k,n

    real :: kwv, lwv, mu, c, om, n2t, n2i, n2c, Hi, Hc, HT
    real :: thermo, Zm, rTt, thlt, qt, thl0t, thl0i
    real :: psfc, tsfc, thrsfc, pisfc, rst, Ta, dlogrT
    complex :: c_c, cj_c, clast, ctemp, mi, mt, mc, B_A
    double precision :: thl

    print *, 'Generating Initial perturbation State for the inversion wave'

    ! Save user input variables
    kwv = var14
    lwv = var15
    mu  = sqrt(kwv**2 + lwv**2) !Total wave number
    cj_c = complex(var16, 0)

    ! Parameters from base
    psfc   = var1
    pisfc  = (psfc/p00)**(rd/cp)
    tsfc   = var2
    thrsfc = Tsfc/pisfc*(1.0 + reps*rslf(psfc,Tsfc))/(1.0 + rslf(psfc,Tsfc))
    !n2i    = var3
    !n2t    = var4 
    Hi     = var5
    Hc     = var6
    HT     = zf(1,1,nk+1)

    !Compute N^2 at the cloud edge
    n2c = N2cloudedge()
    n2i = N2inversion()
    n2t = N2tropoedge()

    write(outfile,*)
    write(outfile,*) 'inversionwave: parameters'
    write(outfile,*) 'N^2 troposphere   = ', n2t
    write(outfile,*) 'N^2 inversion     = ', n2i
    write(outfile,*) 'N^2 cloud edge    = ', n2c
    write(outfile,*) 'Domain Top        = ', Ht
    write(outfile,*) 'Inversion Height  = ', Hi
    write(outfile,*) 'Fog Height        = ', Hc
    write(outfile,*) 'x-dir wave num    = ', kwv
    write(outfile,*) 'y-dir wave num    = ', lwv

    !Secant method solve for c
    clast = cj_c*(1.01)

    do while (abs((clast-cj_c)/cj_c).ge.1e-5)
        ctemp = cj_c
        cj_c = cj_c - eigcond(cj_c)*(cj_c - clast)/(eigcond(cj_c) - eigcond(clast))
        clast = ctemp
    enddo

    write(outfile,*) 'wave speed        = ', cj_c

    c  = real(cj_c)
    om = c*mu

    mt = sqrt(complex(mu**2,0.0) - complex(n2t,0.0)/c**2)
    mi = sqrt(complex(n2i,0.0)/c**2 - complex(mu,0.0)**2)
    mc = sqrt(complex(n2c,0.0)/c**2 - complex(mu,0.0)**2)

    write(outfile,*) 'z-dir wave num t  = ', mt*complex(0.0,1.0)
    write(outfile,*) 'z-dir wave num i  = ', mi
    write(outfile,*) 'z-dir wave num c  = ', mc
    write(outfile,*)

    !Continuity parameter
    B_A = mi/(mi*1/tan(mi*(Hi-Hc))+mc*1/tan(mc*Hc))/sin(mi*(Hi-Hc))
    
    !--------------------------------------!
    !          perturb winds               !
    !--------------------------------------!

    ! u is (xf,yh,zh) grid
    do k=1,nk
    do j=1,nj
    do i=1,ni+1
        !Above inversion
        if(zh(i,j,k).ge.Hi)then
            ua(i,j,k) = u0(i,j,k) - var17*kwv/mu**2*cos(kwv*xf(i))*cos(lwv*yh(j)) &
                                    *real( mt*cosh(mt*(zh(i,j,k)-HT))/sinh(mt*(Hi-HT)) )
        !Above cloud in inversion
        elseif(zh(i,j,k).ge.Hc)then
            ua(i,j,k) = u0(i,j,k) - var17*kwv/mu**2*cos(kwv*xf(i))*cos(lwv*yh(j)) &
                                    *real( mi*cos(mi*(zh(i,j,k)-Hc))/sin(mi*(Hi-Hc)) &
                                     + B_A*mi*cos(mi*(zh(i,j,k)-Hi))/sin(mi*(Hc-Hi)) )
        !In the cloud
        else
            ua(i,j,k) = u0(i,j,k) - var17*kwv/mu**2*cos(kwv*xf(i))*cos(lwv*yh(j)) &
                                    *real( B_A*mc*cos(mc*zh(i,j,k))/sin(mc*Hc) )
        endif
    enddo
    enddo
    enddo

    ! v is (xh,yf,zh) grid
    do i=1,ni
    do j=1,nj+1
    do k=1,nk
        !Above inversion
        if(zh(i,j,k).ge.Hi)then
            va(i,j,k) = v0(i,j,k) + var17*lwv/mu**2*sin(kwv*xh(i))*sin(lwv*yf(j)) &
                                    *real( mt*cosh(mt*(zh(i,j,k)-HT))/sinh(mt*(Hi-HT)) )
        !Above cloud in inversion
        elseif(zh(i,j,k).ge.Hc)then
            va(i,j,k) = v0(i,j,k) + var17*lwv/mu**2*sin(kwv*xh(i))*sin(lwv*yf(j)) &
                                    *real( mi*cos(mi*(zh(i,j,k)-Hc))/sin(mi*(Hi-Hc)) &
                                     + B_A*mi*cos(mi*(zh(i,j,k)-Hi))/sin(mi*(Hc-Hi)) )
        !In the cloud
        else
            va(i,j,k) = v0(i,j,k) + var17*lwv/mu**2*sin(kwv*xh(i))*sin(lwv*yf(j)) &
                                    *real( B_A*mc*cos(mc*zh(i,j,k))/sin(mc*Hc) )
        endif
    enddo
    enddo
    enddo

    ! w is (xh,yh,zf) grid
    do i=1,ni
    do j=1,nj
    do k=1,nk+1
        !Above inversion
        if(zf(i,j,k).ge.Hi)then
            wa(i,j,k) = -var17*sin(kwv*xh(i))*cos(lwv*yf(j)) &
                         *real( sinh(mt*(zf(i,j,k)-HT))/sinh(mt*(Hi-HT)) )
        !Above cloud in inversion
        elseif(zf(i,j,k).ge.Hc)then
            wa(i,j,k) = -var17*sin(kwv*xh(i))*cos(lwv*yf(j)) &
                         *real( sin(mi*(zf(i,j,k)-Hc))/sin(mi*(Hi-Hc)) &
                          + B_A*sin(mi*(zf(i,j,k)-Hi))/sin(mi*(Hc-Hi)) )
        !In the cloud
        else
            wa(i,j,k) = -var17*sin(kwv*xh(i))*cos(lwv*yf(j)) &
                         *real( B_A*sin(mc*zf(i,j,k))/sin(mc*Hc) )
        endif
    enddo
    enddo
    enddo

    do j=jb,je
    do i=ib,ie
        !Compute new interface location
        Zm = Hi - var17/om*cos(kwv*xh(i))*cos(lwv*yh(j))
        do k=1,ke
            
            !Size of thermodynamic perturbation at each point
            if(zh(i,j,k).ge.Hi)then
                thermo = var17/om*cos(kwv*xh(i))*cos(lwv*yh(j)) &
                            *real( sinh(mt*(zh(i,j,k)-HT))/sinh(mt*(Hi-HT)) )
            elseif(zh(i,j,k).ge.Hc)then
                thermo = var17/om*cos(kwv*xh(i))*cos(lwv*yh(j)) &
                            *real( sin(mi*(zh(i,j,k)-Hc))/sin(mi*(Hi-Hc)) &
                            + B_A*sin(mi*(zh(i,j,k)-Hi))/sin(mi*(Hc-Hi)) )
            else
                thermo = var17/om*cos(kwv*xh(i))*cos(lwv*yh(j)) &
                            *real( B_A*sin(mc*zh(i,j,k))/sin(mc*Hc) )
            endif

            !Perturb rT use FD for gradient
            ! Finite difference should be ok for now at least...
            if(k.eq.1)then !one sided formula
                dlogrT = (-3*log((qv0(i,j,k)+qc0(i,j,k))) + 4*log(qv0(i,j,k+1)+qc0(i,j,k+1)) - log(qv0(i,j,k+2)+qc0(i,j,k+2)))/(zh(i,j,k+2) - zh(i,j,k))
            elseif(k.eq.ke)then !one sided formula
                dlogrT = (3*log(qv0(i,j,k)+qc0(i,j,k)) - 4*log(qv0(i,j,k-1)+qc0(i,j,k-1)) + log(qv0(i,j,k-2)+qc0(i,j,k-2)))/(zh(i,j,k) - zh(i,j,k-2))
            else
                dlogrT = log( (qv0(i,j,k+1)+qc0(i,j,k+1))/(qv0(i,j,k-1)+qc0(i,j,k-1)) )/( zh(i,j,k+1) - zh(i,j,k-1) )
            endif

            rTt = thermo*dlogrT
            qt  = (qv0(i,j,k)+qc0(i,j,k))*(1 + rTt)

            !Perturb theta_l mind the new interface location
            if(zh(i,j,k).le.Hi.and. zh(i,j,k).le.Zm)then !below Hi - below interface
                thlt = thermo*compute_dlthl0_dz(.True., zh(i,j,k), zh(i,j,k+1)-zh(i,j,k))
            elseif(zh(i,j,k).le.Zm)then                   !above Hi - below interface
                thlt = thermo*compute_dlthl0_dz(.True., zh(i,j,k), zh(i,j,k+1)-zh(i,j,k)) &
                     + log(compute_thl0(.True.,zh(i,j,k))/compute_thl0(.False.,zh(i,j,k)))
            elseif(zh(i,j,k).ge.Hi)then                   !above Hi - above interface
                thlt = thermo*compute_dlthl0_dz(.False., zh(i,j,k), zh(i,j,k)-zh(i,j,k-1))
            else                                          !below Hi - above interface
                thlt = thermo*compute_dlthl0_dz(.False., zh(i,j,k), zh(i,j,k)-zh(i,j,k-1)) &
                     + log(compute_thl0(.False.,zh(i,j,k))/compute_thl0(.True.,zh(i,j,k)))
            endif
            thl = dble(thl0(i,j,k))*(1.0D0 + dble(thlt))

            !Nonlinear solve for Ta with rtt and thlt
            Ta = Ta_rootfind(dble(prs0(i,j,k)), thl, dble(qT), dble(pi0(i,j,k)*th0(i,j,k)), dble(thlt), dble(rtt))

            !CM1 dry theta additive perturbation
            tha(i,j,k) = Ta/pi0(i,j,k)

            !Perturbed water states
            rst = rslf(prs0(i,j,k), pi0(i,j,k)*th0(i,j,k)+Ta)
            if(rst.ge.qT)then
                qa(i,j,k,nqv) = qT
                qa(i,j,k,nqc) = 0.0
            else
                qa(i,j,k,nqv) = rst
                qa(i,j,k,nqc) = qT - rst
            endif

        enddo
    enddo
    enddo

    call bcu(ua)
    call bcw(wa,1)

    return

    CONTAINS

    real function N2tropoedge()

        real :: ptropo, qTtropo, dthltropo, dqTtropo, dlogTr_dlogrT_clear, Rtot, cptot
        real :: zT, zB, dzT, dzB

        integer :: k

        k = 1
        do while(zh(1,1,k).lt.Hi)
            k = k + 1
        enddo
        
        !Cloud edge is a grid point
        if(zh(1,1,k).eq.Hi)then
            ptropo    = prs0(1,1,k)
            qTtropo   = qv0(1,1,k)
            dqTtropo  = log(qv0(1,1,k+1)/qv0(1,1,k-1))/(zh(1,1,k+1)-zh(1,1,k-1))

        !Cloud edge is between zh(k-1) and zh(k) interpolate values
        else
            ptropo  = prs0(1,1,k-1)*(zh(1,1,k)-Hi)/(zh(1,1,k)-zh(1,1,k-1))&
                    +prs0(1,1,k)*(Hi-zh(1,1,k-1))/(zh(1,1,k)-zh(1,1,k-1))
            qTtropo = qv0(1,1,k-1)*(zh(1,1,k)-Hi)/(zh(1,1,k)-zh(1,1,k-1))&
                    +qv0(1,1,k)*(Hi-zh(1,1,k-1))/(zh(1,1,k)-zh(1,1,k-1))
            
            !Cloud edge is a half grid point
            if((zh(1,1,k+1)+zh(1,1,k-1))/2.eq.Hi)then
                dqTtropo  = log(qv0(1,1,k)/qv0(1,1,k-1))/(zh(1,1,k)-zh(1,1,k-1))
            else
                !calculate d/dz above and below then interpolate
                zT  = (zh(1,1,k+1)+zh(1,1,k))/2
                zB  = (zh(1,1,k-1)+zh(1,1,k-2))/2

                !rT
                dzT = log(qv0(1,1,k+1)/qv0(1,1,k))/(zh(1,1,k+1)-zh(1,1,k))
                dzB = log(qv0(1,1,k-1)/qv0(1,1,k-2))/(zh(1,1,k-1)-zh(1,1,k-2))

                dqTtropo = dzB*(zT-Hi)/(zT-zB) + dzT*(Hi-zB)/(zT-zB)
            endif

        endif

        dthltropo = compute_dlthl0_dz(.False., Hi, zh(1,1,k+1)-zh(1,1,k))

        Rtot = Rd + qTtropo*Rv
        cptot = cp + qTtropo*cpv
        dlogTr_dlogrT_clear = (Rv-Rd)/Rtot*qTtropo/(1+qTtropo) &
                            + qTtropo*(Rv*cp - cpv*Rd)/cptot**2*log(ptropo/p00)

        N2tropoedge = g*(dthltropo +  dlogTr_dlogrT_clear*dqTtropo)

    end function N2tropoedge

    real function N2cloudedge()

        real :: Tcld, pcld, dthlcld, dqTcld
        real :: zT, zB, dzT, dzB

        integer :: k

        k = 1
        do while(zh(1,1,k).lt.Hc)
            k = k + 1
        enddo
        
        !Cloud edge is a grid point
        if(zh(1,1,k).eq.Hc)then
            Tcld    = th0(1,1,k)*pi0(1,1,k)
            pcld    = prs0(1,1,k)
            dthlcld = log(thl0(1,1,k+1)/thl0(1,1,k-1))/(zh(1,1,k+1)-zh(1,1,k-1))
            dqTcld  = log(qv0(1,1,k+1)/(qv0(1,1,k-1)+qc0(1,1,k-1)))/(zh(1,1,k+1)-zh(1,1,k-1))

        !Cloud edge is between zh(k-1) and zh(k) interpolate values
        else
            Tcld = th0(1,1,k-1)*pi0(1,1,k-1)*(zh(1,1,k)-Hc)/(zh(1,1,k)-zh(1,1,k-1))&
                    +th0(1,1,k)*pi0(1,1,k)*(Hc-zh(1,1,k-1))/(zh(1,1,k)-zh(1,1,k-1))
            pcld = prs0(1,1,k-1)*(zh(1,1,k)-Hc)/(zh(1,1,k)-zh(1,1,k-1))&
                    +prs0(1,1,k)*(Hc-zh(1,1,k-1))/(zh(1,1,k)-zh(1,1,k-1))
            
            !Cloud edge is a half grid point
            if((zh(1,1,k+1)+zh(1,1,k-1))/2.eq.Hc)then
                dthlcld = log(thl0(1,1,k)/thl0(1,1,k-1))/(zh(1,1,k)-zh(1,1,k-1))
                dqTcld  = log(qv0(1,1,k)/(qv0(1,1,k-1)+qc0(1,1,k-1)))/(zh(1,1,k)-zh(1,1,k-1))
            else
                !calculate d/dz above and below then interpolate
                !thl
                dzT = log(thl0(1,1,k+1)/thl0(1,1,k))/(zh(1,1,k+1)-zh(1,1,k))
                dzB = log(thl0(1,1,k-1)/thl0(1,1,k-2))/(zh(1,1,k-1)-zh(1,1,k-2))
                zT  = (zh(1,1,k+1)+zh(1,1,k))/2
                zB  = (zh(1,1,k-1)+zh(1,1,k-2))/2

                dthlcld = dzB*(zT-Hc)/(zT-zB) + dzT*(Hc-zB)/(zT-zB)

                !rT
                dzT = log(qv0(1,1,k+1)/qv0(1,1,k))/(zh(1,1,k+1)-zh(1,1,k))
                dzB = log((qv0(1,1,k-1)+qc0(1,1,k-1))/(qv0(1,1,k-2)+qc0(1,1,k-2)))/(zh(1,1,k-1)-zh(1,1,k-2))

                dqTcld = dzB*(zT-Hc)/(zT-zB) + dzT*(Hc-zB)/(zT-zB)
            endif

        endif

        N2cloudedge = g*(dthlcld*dlTr_dlthl(pcld,Tcld) + dqTcld*dlTr_dlrT(pcld,Tcld))

    end function N2cloudedge

    real function N2inversion()

        real :: running_sum, dlogTr, dlogp, rtot, cptot

        integer :: k,n

        n = 0
        running_sum = 0.0
        do k=1,nk
            if(zh(1,1,k).le.Hi .and. zh(1,1,k+1).le.Hi .and. zh(1,1,k).ge.Hc .and. zh(1,1,k+1).ge.Hc)then
                n = n + 1
                dlogp  = log(prs0(1,1,k+1)/prs0(1,1,k))/(zh(1,1,k+1)-zh(1,1,k))
                dlogTr = log(( th0(1,1,k+1)*pi0(1,1,k+1)*(1 + reps*qv0(1,1,k+1))/(1 + qv0(1,1,k+1)) )&
                            /( th0(1,1,k)  *pi0(1,1,k)  *(1 + reps*qv0(1,1,k))  /(1 + qv0(1,1,k)) ))&
                            /(zh(1,1,k+1)-zh(1,1,k))
                rtot  = rd +  rv*(qv0(1,1,k)+qv0(1,1,k+1))/2
                cptot = cp + cpv*(qv0(1,1,k)+qv0(1,1,k+1))/2
                running_sum = running_sum + g*(dlogTr - (rtot)/(cptot)*dlogp)
            endif
        enddo

        N2inversion = running_sum/n

    end function N2inversion

    real function dlTr_dlthl(prs,temp)
        real :: prs, temp, lamb, lambR, lambc, rtot, cptot, rst, lv_T
        real :: drl_dlthl
        
        lv_T  = lv1 - lv2*temp
        rst   = rslf(prs, temp)
        rtot  = rd + rst*rv
        cptot = cp + rst*cpv
        lambR = lv_T/rv/temp
        lambc = lv_T/cptot/temp
        lamb  = lambc*lambR*rtot/rd*rst

        drl_dlthl  = -lambR*rtot/rd*rst/(1 + lamb)

        dlTr_dlthl = 1 + drl_dlthl*(lambc - rv/rtot)
    
    end function dlTr_dlthl

    real function dlTr_dlrT(prs, temp)
        real :: prs, temp, lamb, lambR, lambc, rtot, cptot, rst, lv_T
        real :: drl_dlrT, Pterm

        lv_T  = lv1 - lv2*temp
        rst   = rslf(prs, temp)
        rtot  = rd + rst*rv
        cptot = cp + rst*cpv
        lambR = lv_T/rv/temp
        lambc = lv_T/cptot/temp
        lamb  = lambc*lambR*rtot/rd*rst

        Pterm = (Rv*cp - cpv*Rd)/(cptot**2)*rst*log(prs/p00)

        drl_dlrT  = rst*(1 - lambR*rtot/rd*Pterm)/(1 + lamb)

        dlTr_dlrT = (rv - rd)/rtot*rst/(1 + rst) + Pterm + drl_dlrT*(lambc - rv/rtot)

    end function dlTr_dlrT

    complex function eigcond(c)

        complex :: c, mt, mi, mc

        mt = sqrt(complex(mu**2,0.0) - complex(n2t,0.0)/c**2)
        mi = sqrt(complex(n2i,0.0)/c**2 - complex(mu,0.0)**2)
        mc = sqrt(complex(n2c,0.0)/c**2 - complex(mu,0.0)**2)

        eigcond = mi**2/sin(mi*(Hi-Hc))**2 &
                    + (mt*1/tanh(mT*(Hi-zh(1,1,nk))) - mi*1/tan(mi*(Hi-Hc))) &
                    * (mi*1/tan(mi*(Hi-Hc)) + mc*1/tan(mc*Hc))
    
    end function eigcond

    real function compute_thl0(inversion, z)
        logical :: inversion
        real :: z, thr, pi, prs, Tlast, Temp, rst

        !Star backgrounds of thr and pi for each region
        !Note that var3 is N2i the background was built on
        ! and var4 is N2t but these are not the values once
        ! the cloud water perturbation is added!
        if(inversion)then
            thr = thrsfc*exp(var3/g*z)
            pi  = pisfc - g**2/cp/thrsfc/var3*(1 - exp(-var3/g*z))
        else
            thr = thrsfc*exp((var3-var4)/g*Hi + var4/g*z)
            pi  = pisfc - g**2/cp/thrsfc*(1/var3 + (1/var4 - 1/var3)*exp(-var3/g*Hi) &
                                         -1/var4*exp((var4 - var3)/g*Hi - var4/g*z) )
        endif
        prs = p00*(pi**(cp/Rd))

        !Nonlinear solve for temp and rst
        Temp  = thr*pi
        Tlast = 0.0
        do while(abs((Temp-Tlast)/Temp).ge.1e-6)
            Tlast = Temp
            rst   = rslf(prs, Temp)
            Temp  = thr*pi*(1.0 + rst)/(1.0 + reps*rst)
        enddo

        ! Dont really need this precision here but just for convience
        compute_thl0 = thl_func(dble(prs), dble(Temp), dble(rst))

    end function compute_thl0

    real function compute_dlthl0_dz(inversion, z, dz)
        logical :: inversion
        real :: z, dz

        compute_dlthl0_dz = log(compute_thl0(inversion, z+dz/2.)/compute_thl0(inversion, z-dz/2.))/dz

    end function compute_dlthl0_dz

    double precision function Ta_rootfind(prs,thl,qt,Tbar,thlt,rtt)

        double precision :: prs, thl, qt, Tbar, Ta, Tlast, rtot, cptot, rst
        double precision :: thlt, rtt, err, errlast, upper, lower

        !Define R_T and (c_p)_T
        rtot  = rd + qt*rv
        cptot = cp + qt*cpv

        !Try clear air first (explicit)
        Ta = thl*(prs/p00)**(rtot/cptot) - Tbar

        !Check for consistency
        !rst = dble(rslf(real(prs), real(Tbar + Ta)))
        rst = dbl_rslf(prs, Tbar + Ta)

        !In cloud need nonlinear root finding
        !otherwise we're done
        IF(rst.le.qt)THEN

            Tlast = 0.0
            n = 0

            ! Use linearized formula for first guess
            Ta = Tbar*(dlT_dlthl(prs,Tbar + Ta)*thlt + dlT_dlrT(prs,Tbar + Ta)*rtt)
            !write(outfile, *) Tbar, thlt, rtt

            errlast = 0.0
            err     = log(thl_func(prs, Tbar+Ta, qt)/thl)

            do while(abs( err ).ge.1e-14 .and. (err*errlast).ge.0.0)
                n = n+1
                if(n.ge.50) stop 1111
                !write(outfile, *) log(thl_func(prs, Tbar+Ta, qt)/thl), Ta, dlT_dlthl(prs, Tbar+Ta)
                Tlast = Ta
                Ta = Ta - (Tbar + Ta)*log(thl_func(prs, Tbar+Ta, qt)/thl)*dlT_dlthl(prs, Tbar+Ta)
                errlast = err
                err = log(thl_func(prs, Tbar+Ta, qt)/thl)
            enddo

            !Newton iteration failed to converge use bisection
            if((err*errlast).lt.0.0)then
                if(err.gt.0.0)then
                    upper = Ta
                    lower = Tlast
                else
                    upper = Tlast
                    lower = Ta
                endif

                n=0
                do while(abs((upper-lower)/Ta).ge.1e-7)
                    n=n+1
                    if(n.ge.100) stop 1111
                    Ta = (upper + lower)/2
                    err = log(thl_func(prs, Tbar+Ta, qt)/thl)
                    if(err.gt.0.0)then
                        upper = Ta
                    else
                        lower = Ta
                    endif
                    !write(outfile, *) log(thl_func(prs, Tbar+upper, qt)/thl), log(thl_func(prs, Tbar+lower, qt)/thl), Ta
                enddo
            endif

            !write(outfile, *) 'converged'

        ENDIF

        Ta_rootfind = Ta

    end function Ta_rootfind

    double precision function dlT_dlthl(prs,temp)
        double precision :: prs, temp, lamb, lambR, lambc, rtot, cptot, rst, lv_T
        
        lv_T  = dble(lv1) - dble(lv2)*temp
        !rst   = dble(rslf(real(prs), real(temp)))
        rst   = dbl_rslf(prs, temp)
        rtot  = rd + rst*rv
        cptot = cp + rst*cpv
        lambR = lv_T/rv/temp
        lambc = lv_T/cptot/temp
        lamb  = lambc*lambR*rtot/rd*rst

        dlT_dlthl = 1/(1+lamb)
    
    end function dlT_dlthl

    double precision function dlT_dlrT(prs,temp)
        double precision :: prs, temp, lamb, lambR, lambc, rtot, cptot, rst, lv_T
        
        lv_T  = dble(lv1) - dble(lv2)*temp
        !rst   = dble(rslf(real(prs), real(temp)))
        rst   = dbl_rslf(prs, temp)
        rtot  = rd + rst*rv
        cptot = cp + rst*cpv
        lambR = lv_T/rv/temp
        lambc = lv_T/cptot/temp
        lamb  = lambc*lambR*rtot/rd*rst

        dlT_dlrT = lambc*rst/(1+lamb)
    
    end function dlT_dlrT

    double precision function thl_func(prs,temp,qt)
        double precision :: prs, temp, qt, lambc, rtot, cptot, rst, lv_T, qv, qc

        lv_T  = dble(lv1) - dble(lv2)*temp

        !rst   = dble(rslf(real(prs), real(temp)))
        rst   = dbl_rslf(prs, temp)
        IF(rst.lt.qt)THEN
            qv = rst
            qc = qt-rst
        ELSE
            qv = qt
            qc = 0
        ENDIF

        rtot  = rd + qt*rv
        cptot = cp + qt*cpv
        lambc = lv_T/cptot/temp

        thl_func = temp*(p00/prs)**(rtot/cptot)*exp(-lambc*qc)&
                  *((rd+qv*rv)/rtot)**(rtot/cptot)*(qt/qv)**(qt*rv/cptot)

    end function thl_func

    double precision function dbl_rslf(prs, temp)

        double precision :: prs, temp, esl

        esl=611.2D0 * EXP( 17.67D0 * ( Temp  - 273.15D0 ) / ( Temp  - 29.65D0 ) )
        ! 171023 (fix for very cold temps):
        esl = min( esl , prs*0.5D0 )
        dbl_rslf= dble(eps) * ESL /(Prs-ESL)

    end function dbl_rslf

end subroutine inversionwave

!-----------------------------------------------------------------------------
!
!  subroutine linearshear_mode:  
!
!  &param8 inputs :
!            var14 : non-dimensional wave number
!            var15 : real part of non-dimensional phase speed
!            var16 : imaginary part of non-dimensional phase speed
!            var17 : wave amplitude
!
!  NOTES: BLG 08 Jun 2025
!
!-----------------------------------------------------------------------------

subroutine linearshear_mode(xh,xf,yh,yf,zh,zf,pi0,prs0,th0,thl0,&
                            qv0,qc0,rst0,u0,v0,ua,va,wa,tha,qa)

    use input
    use constants
    use cm1libs , only : rslf
    use bc_module

    implicit none

    real, dimension(ib:ie) :: xh
    real, dimension(ib:ie+1) :: xf
    real, dimension(jb:je) :: yh
    real, dimension(jb:je+1) :: yf
    real, dimension(ib:ie,jb:je,kb:ke) :: zh
    real, dimension(ib:ie,jb:je,kb:ke+1) :: zf
    real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,th0,qv0,qc0,t0,thl0,rst0
    real, dimension(ib:ie,jb:je,kb:ke) :: tha
    real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
    real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua
    real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va
    real, dimension(ib:ie,jb:je,kb:ke+1) :: wa

    integer :: i,j,k,n

    real :: Hc, Hd, Uinf, kwv, ns, thlt, rTt, dlogthl, dlogrT, rst, qT, Ta
    complex :: c, muT, muL, psi, acoeff, bcoeff

    print *, 'Generating Initial perturbation State for linear shear single mode'

    !Parameters from background state for use with isnd=1301-3 and iwnd=1300
    Hc   = var4
    Hd   = var5
    Uinf = var10

    !non-dimensional wave parameters
    kwv = var14
    ns = var3*(Hd/Uinf)**2
    c = cmplx(var15,var16)

    write(outfile,*)
    write(outfile,*) 'linearshear_mode: non-dimensional parameters'
    write(outfile,*) 'N^2  = ', ns
    write(outfile,*) 'kwv  = ', kwv
    write(outfile,*) 'c    = ', c
    write(outfile,*)

    write(outfile,*) '------------------------------------------------------------'
    write(outfile,*) 'zh        dlogrT/dz         dlogthl/dz'
    write(outfile,*)

    muT = sqrt(kwv**2 - ns/(1-c)**2)
    !Fix possible branch cut issues
    if(REALPART(muT).eq.0.0)then
        muT = cmplx(0,-abs(muT))
    endif
    muL = sqrt(kwv**2 - ns/(1+c)**2)
    !Fix possible branch cut issues
    if(REALPART(muL).eq.0.0)then
        muL = cmplx(0,abs(muL))
    endif

    acoeff = -( (1+c)*(muL+kwv) - 1 )*exp( kwv)
    bcoeff =  ( (1+c)*(muL-kwv) - 1 )*exp(-kwv)

    !--------------------------------------!
    !          perturb winds               !
    !--------------------------------------!

    ! u is (xf,yh,zh) grid
    do k=1,nk
    do j=1,nj
    do i=1,ni+1
        if(zh(i,j,k).le.(Hc-Hd))then
            ua(i,j,k) = u0(i,j,k) - Uinf*REALPART(exp(cmplx(0,kwv*xf(i)/Hd)) &
                        *var17*( acoeff*muL*exp(-kwv)*exp(muL*((zh(i,j,k)-Hc)/Hd + 1)) &
                            + bcoeff*muL*exp( kwv)*exp(muL*((zh(i,j,k)-Hc)/Hd + 1)) ) )
        elseif(zh(i,j,k).le.(Hc+Hd))then
            ua(i,j,k) = u0(i,j,k) - Uinf*REALPART(exp(cmplx(0,kwv*xf(i)/Hd)) &
                        *var17*(  acoeff*kwv*exp( kwv*(zh(i,j,k)-Hc)/Hd) &
                                - bcoeff*kwv*exp(-kwv*(zh(i,j,k)-Hc)/Hd)) )
        else
            ua(i,j,k) = u0(i,j,k) - Uinf*REALPART(exp(cmplx(0,kwv*xf(i)/Hd)) &
                        *var17*( -acoeff*muT*exp( kwv)*exp(-muT*((zh(i,j,k)-Hc)/Hd - 1)) &
                                -bcoeff*muT*exp(-kwv)*exp(-muT*((zh(i,j,k)-Hc)/Hd - 1)) ) )
        endif
    enddo
    enddo
    enddo

    ! w is (xh,yh,zf) grid
    do i=1,ni
    do j=1,nj
    do k=1,nk+1
        if(zf(i,j,k).le.(Hc-Hd))then
            wa(i,j,k) = Uinf*REALPART(cmplx(0,kwv)*exp(cmplx(0,kwv*xf(i)/Hd)) &
                        *var17*( acoeff*exp(-kwv)*exp(muL*((zf(i,j,k)-Hc)/Hd + 1)) &
                            + bcoeff*exp( kwv)*exp(muL*((zf(i,j,k)-Hc)/Hd + 1)) ) )
        elseif(zf(i,j,k).le.(Hc+Hd))then
            wa(i,j,k) = Uinf*REALPART(cmplx(0,kwv)*exp(cmplx(0,kwv*xf(i)/Hd)) &
                        *var17*( acoeff*exp( kwv*(zf(i,j,k)-Hc)/Hd) &
                            + bcoeff*exp(-kwv*(zf(i,j,k)-Hc)/Hd)) )
        else
            wa(i,j,k) = Uinf*REALPART(cmplx(0,kwv)*exp(cmplx(0,kwv*xf(i)/Hd)) &
                        *var17*( acoeff*exp( kwv)*exp(-muT*((zf(i,j,k)-Hc)/Hd - 1)) &
                            + bcoeff*exp(-kwv)*exp(-muT*((zf(i,j,k)-Hc)/Hd - 1)) ) )
        endif
    enddo
    enddo
    enddo

    !--------------------------------------!
    !             compute psi              !
    !--------------------------------------!

    do j=jb,je
    do i=ib,ie
    do k=1,ke
        !psi on (xh,yh,zh) grid (careful of re-dimensionalization here)
        if(zh(i,j,k).le.(Hc-Hd))then
            psi = Uinf*Hd*exp(cmplx(0,kwv*xf(i)/Hd)) &
                        *var17*(acoeff*exp(-kwv)*exp(muL*((zh(i,j,k)-Hc)/Hd + 1)) &
                            + bcoeff*exp( kwv)*exp(muL*((zh(i,j,k)-Hc)/Hd + 1)) )
        elseif(zh(i,j,k).le.(Hc+Hd))then
            psi = Uinf*Hd*exp(cmplx(0,kwv*xf(i)/Hd)) &
                        *var17*( acoeff*exp( kwv*(zh(i,j,k)-Hc)/Hd) &
                            + bcoeff*exp(-kwv*(zh(i,j,k)-Hc)/Hd))
        else
            psi = Uinf*Hd*exp(cmplx(0,kwv*xf(i)/Hd)) &
                        *var17*( acoeff*exp( kwv)*exp(-muT*((zh(i,j,k)-Hc)/Hd - 1)) &
                            + bcoeff*exp(-kwv)*exp(-muT*((zh(i,j,k)-Hc)/Hd - 1)) )
        endif

        !--------------------------------------!
        !           perturb thermo             !
        !--------------------------------------!

        ! Calc derivatives of background
        ! Finite difference should be ok for now at least...
        if(k.eq.1)then !one sided formula
            dlogrT = (-3*log((qv0(i,j,k)+qc0(i,j,k))) + 4*log(qv0(i,j,k+1)+qc0(i,j,k+1)) - log(qv0(i,j,k+2)+qc0(i,j,k+2)))/(zh(i,j,k+2) - zh(i,j,k))
            dlogthl = (-3*log(thl0(i,j,k)) + 4*log(thl0(i,j,k+1)) - log(thl0(i,j,k+2)))/(zh(i,j,k+2) - zh(i,j,k))
        elseif(k.eq.ke)then !one sided formula
            dlogrT = (3*log(qv0(i,j,k)+qc0(i,j,k)) - 4*log(qv0(i,j,k-1)+qc0(i,j,k-1)) + log(qv0(i,j,k-2)+qc0(i,j,k-2)))/(zh(i,j,k) - zh(i,j,k-2))
            dlogthl = (3*log(thl0(i,j,k)) - 4*log(thl0(i,j,k-1)) + log(thl0(i,j,k-2)))/(zh(i,j,k) - zh(i,j,k-2))
        else
            dlogrT = log( (qv0(i,j,k+1)+qc0(i,j,k+1))/(qv0(i,j,k-1)+qc0(i,j,k-1)) )/( zh(i,j,k+1) - zh(i,j,k-1) )
            dlogthl = log( thl0(i,j,k+1)/thl0(i,j,k-1) )/( zh(i,j,k+1) - zh(i,j,k-1) )
        endif

        if((i.eq.1).and.(j.eq.1)) write(outfile,*) zh(i,j,k), dlogrT, dlogthl

        !Percent perturbations to conserved variables
        rTt  = -dlogrT *REALPART(psi/(u0(i,j,k)-c*Uinf))
        thlt = -dlogthl*REALPART(psi/(u0(i,j,k)-c*Uinf))

        !New total water
        qT = (qv0(i,j,k)+qc0(i,j,k))*(1+rTt)

        !Nonlinear solve for additive Temp perturbation
        Ta = Ta_rootfind(prs0(i,j,k), thl0(i,j,k)*(1+thlt), qT, pi0(i,j,k)*th0(i,j,k))

        !CM1 dry theta additive perturbation
        tha(i,j,k) = Ta/pi0(i,j,k)

        !Perturbed water states
        rst = rslf(prs0(i,j,k), pi0(i,j,k)*th0(i,j,k)+Ta)
        if(rst.ge.qT)then
            qa(i,j,k,nqv) = qT
            qa(i,j,k,nqc) = 0.0
        else
            qa(i,j,k,nqv) = rst
            qa(i,j,k,nqc) = qT - rst
        endif

    enddo
    enddo
    enddo

    call bcu(ua)
    call bcw(wa,1)

    return

    CONTAINS

    real function Ta_rootfind(prs,thl,qt,Tbar)

        real :: prs, thl, qt, Tbar, Ta, Tlast, rtot, cptot, rst

        !Define R_T and (c_p)_T
        rtot  = rd + qt*rv
        cptot = cp + qt*cpv

        !Try clear air first (explicit)
        Ta = thl*(prs/p00)**(rtot/cptot) - Tbar

        !Check for consistency
        rst = rslf(prs, Tbar + Ta)

        !In cloud need nonlinear root finding
        !otherwise we're done
        IF(rst.le.qt)THEN

            Tlast = 0.0
            n = 0
            do while(abs( log(thl_func(prs, Tbar+Ta, qt)/thl) ).ge.1e-6)
                n = n+1
                if(n.ge.50) stop 1111
                Tlast = Ta
                Ta = Ta - (Tbar + Ta)*log(thl_func(prs, Tbar+Ta, qt)/thl)*dlT_dlthl(prs, Tbar+Ta)
            enddo

        ENDIF

        Ta_rootfind = Ta

    end function Ta_rootfind

    real function dlT_dlthl(prs,temp)
        real :: prs, temp, lamb, lambR, lambc, rtot, cptot, rst, lv_T
        
        lv_T  = lv1 - lv2*temp
        rst   = rslf(prs, temp)
        rtot  = rd + rst*rv
        cptot = cp + rst*cpv
        lambR = lv_T/rv/temp
        lambc = lv_T/cptot/temp
        lamb  = lambc*lambR*rtot/rd*rst

        dlT_dlthl = 1/(1+lamb)
    
    end function dlT_dlthl

    real function thl_func(prs,temp,qt)
        real :: prs, temp, qt, lambc, rtot, cptot, rst, lv_T, qv, qc

        lv_T  = lv1 - lv2*temp

        rst   = rslf(prs, temp)
        IF(rst.lt.qt)THEN
            qv = rst
            qc = qt-rst
        ELSE
            qv = qt
            qc = 0
        ENDIF

        rtot  = rd + qt*rv
        cptot = cp + qt*cpv
        lambc = lv_T/cptot/temp

        thl_func = temp*(p00/prs)**(rtot/cptot)*exp(-lambc*qc)&
                  *((rd+qv*rv)/rtot)**(rtot/cptot)*(qt/qv)**(qt*rv/cptot)

    end function thl_func

end subroutine linearshear_mode

!-----------------------------------------------------------------------------
!
!  subroutine cldoverclear_wave: Wave initialization from Walsh and Muraki (2024).
!
!  &param8 inputs :
!            var14 : horizontal (x-direction) wave number [rad/m]
!            var15 : horizontal (y-direction) wave number [rad/m]
!            var16 : wave speed initial guess [m/s]
!            var17 : wave amplitude
!
!       inputs from base (isnd=1305)
!            var1  : surface pressure [Pa]
!            var2  : surface temperature [K]
!            var3  : Constant N^2 (unsaturated) [1/s^2]
!            var4  : Height of cloud edge [m]
!
!  NOTES: BLG 12 Jun 2025
!        - Wave speed and eigenmode is generated by an interal nonlinear solve.
!        - Setting var15 = 0 does the 2D case
!        - 3D wave traveling in the x-direction
!        - Uses FD to calculate gradients of background state
!        - Uses frozen coeff. for N^2 but z-dependent background gradients 
!
!-----------------------------------------------------------------------------

subroutine cldoverclear_wave(xh,xf,yh,yf,zh,zf,pi0,prs0,th0,thl0,&
                            qv0,qc0,rst0,u0,v0,ua,va,wa,tha,qa)

    use input
    use constants
    use cm1libs , only : rslf
    use bc_module

    implicit none

    real, dimension(ib:ie) :: xh
    real, dimension(ib:ie+1) :: xf
    real, dimension(jb:je) :: yh
    real, dimension(jb:je+1) :: yf
    real, dimension(ib:ie,jb:je,kb:ke) :: zh
    real, dimension(ib:ie,jb:je,kb:ke+1) :: zf
    real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,th0,qv0,qc0,t0,thl0,rst0
    real, dimension(ib:ie,jb:je,kb:ke) :: tha
    real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
    real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua
    real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va
    real, dimension(ib:ie,jb:je,kb:ke+1) :: wa

    integer :: i,j,k,n

    real :: kwv, lwv, mu, c, om, n2b, n2c, Hc, HT
    real :: thermo, rTt, thlt, qt, thl, dlogrT, dlogthl
    real :: psfc, tsfc, thrsfc, pisfc, rst, Ta
    complex :: c_c, cj_c, clast, ctemp, mb, mc

    print *, 'Generating Initial perturbation State for cloud over clear wave from Muraki and Walsh'

        ! Save user input variables
    kwv = var14
    lwv = var15
    mu  = sqrt(kwv**2 + lwv**2) !Total wave number
    cj_c = complex(var16, 0)

    ! Parameters from base
    psfc   = var1
    pisfc  = (psfc/p00)**(rd/cp)
    tsfc   = var2
    thrsfc = Tsfc/pisfc*(1.0 + reps*rslf(psfc,Tsfc))/(1.0 + rslf(psfc,Tsfc))
    n2b    = var3
    Hc     = var4
    HT     = zf(1,1,nk+1)-Hc

    !Compute N^2 at the cloud edge
    n2c = N2cloudedge()

    write(outfile,*)
    write(outfile,*) 'inversionwave: parameters'
    write(outfile,*) 'N^2 unsat.        = ', n2b
    write(outfile,*) 'N^2 cloud edge    = ', n2c
    write(outfile,*) 'Domain Top        = ', Hc+Ht
    write(outfile,*) 'Cloud edge Height = ', Hc
    write(outfile,*) 'x-dir wave num    = ', kwv
    write(outfile,*) 'y-dir wave num    = ', lwv

    !Secant method solve for c
    clast = cj_c*(1.01)

    n = 0
    do while (abs((clast-cj_c)/cj_c).ge.1e-5)
        n = n + 1
        if(n.ge.50) stop 1111
        ctemp = cj_c
        cj_c = cj_c - eigcond(cj_c)*(cj_c - clast)/(eigcond(cj_c) - eigcond(clast))
        clast = ctemp
    enddo

    write(outfile,*) 'wave speed        = ', cj_c

    c  = real(cj_c)
    om = c*mu

    !Wave in cloud region
    if((mu**2 - n2c/c**2).le.0.0) stop 1111

    mb = sqrt(n2b/c**2 - mu**2)
    mc = sqrt(mu**2 - n2c/c**2)

    write(outfile,*) 'z-dir wave num c  = ', mc
    write(outfile,*) 'z-dir wave num b  = ', mb
    write(outfile,*)

    !--------------------------------------!
    !          perturb winds               !
    !--------------------------------------!

    ! u is (xf,yh,zh) grid
    do k=1,nk
    do j=1,nj
    do i=1,ni+1
        !Clear
        if(zh(i,j,k).le.Hc)then
            ua(i,j,k) = u0(i,j,k) - var17*mb*kwv/mu**2*cos(mb*zh(i,j,k))/sin(mb*Hc) &
                                                      *cos(kwv*xf(i))*cos(lwv*yh(j))
        !Cloud
        else
            ua(i,j,k) = u0(i,j,k) + var17*mc*kwv/mu**2*cosh(mc*(Hc+HT-zh(i,j,k)))/sinh(mc*HT) &
                                                      *cos(kwv*xf(i))*cos(lwv*yh(j))
        endif
    enddo
    enddo
    enddo

    ! v is (xh,yf,zh) grid
    do i=1,ni
    do j=1,nj+1
    do k=1,nk
        !Clear
        if(zh(i,j,k).le.Hc)then
            va(i,j,k) = v0(i,j,k) +  var17*mb*lwv/mu**2*cos(mb*zh(i,j,k))/sin(mb*Hc) &
                                                       *sin(kwv*xf(i))*sin(lwv*yh(j))
        !Cloud
        else
            va(i,j,k) = v0(i,j,k) - var17*mc*lwv/mu**2*cosh(mc*(Hc+HT-zh(i,j,k)))/sinh(mc*HT) &
                                                      *sin(kwv*xf(i))*sin(lwv*yh(j))
        endif
    enddo
    enddo
    enddo

    ! w is (xh,yh,zf) grid
    do i=1,ni
    do j=1,nj
    do k=1,nk+1
        !Clear
        if(zf(i,j,k).le.Hc)then
            wa(i,j,k) = -var17*sin(mb*zf(i,j,k))/sin(mb*Hc) &
                              *sin(kwv*xh(i))*cos(lwv*yh(j))
        !Cloud
        else
            wa(i,j,k) = -var17*sinh(mc*(Hc+HT-zf(i,j,k)))/sinh(mc*HT) &
                              *sin(kwv*xh(i))*cos(lwv*yh(j))
        endif
    enddo
    enddo
    enddo

    !--------------------------------------!
    !           perturb thermo             !
    !--------------------------------------!

    do j=jb,je
    do i=ib,ie
    do k=1,ke
        !Clear
        if(zf(i,j,k).le.Hc)then
            thermo = var17/om*sin(mb*zf(i,j,k))/sin(mb*Hc) &
                             *cos(kwv*xh(i))*cos(lwv*yh(j))
        !Cloud
        else
            thermo = var17/om*sinh(mc*(Hc+HT-zf(i,j,k)))/sinh(mc*HT) &
                             *cos(kwv*xh(i))*cos(lwv*yh(j))
        endif

        ! Calc derivatives of background
        ! Finite difference should be ok for now at least...
        if(k.eq.1)then !one sided formula
            dlogrT = (-3*log((qv0(i,j,k)+qc0(i,j,k))) + 4*log(qv0(i,j,k+1)+qc0(i,j,k+1)) - log(qv0(i,j,k+2)+qc0(i,j,k+2)))/(zh(i,j,k+2) - zh(i,j,k))
            dlogthl = (-3*log(thl0(i,j,k)) + 4*log(thl0(i,j,k+1)) - log(thl0(i,j,k+2)))/(zh(i,j,k+2) - zh(i,j,k))
        elseif(k.eq.ke)then !one sided formula
            dlogrT = (3*log(qv0(i,j,k)+qc0(i,j,k)) - 4*log(qv0(i,j,k-1)+qc0(i,j,k-1)) + log(qv0(i,j,k-2)+qc0(i,j,k-2)))/(zh(i,j,k) - zh(i,j,k-2))
            dlogthl = (3*log(thl0(i,j,k)) - 4*log(thl0(i,j,k-1)) + log(thl0(i,j,k-2)))/(zh(i,j,k) - zh(i,j,k-2))
        else
            dlogrT = log( (qv0(i,j,k+1)+qc0(i,j,k+1))/(qv0(i,j,k-1)+qc0(i,j,k-1)) )/( zh(i,j,k+1) - zh(i,j,k-1) )
            dlogthl = log( thl0(i,j,k+1)/thl0(i,j,k-1) )/( zh(i,j,k+1) - zh(i,j,k-1) )
        endif

        !Perturb rT and thl use FD for gradient
        rTt  = thermo*dlogrT
        qt   = (qv0(i,j,k)+qc0(i,j,k))*(1 + rTt)

        thlt = thermo*dlogthl
        thl  = thl0(i,j,k)*(1 + thlt)

        !Nonlinear solve for Ta with rtt and thlt
        Ta = Ta_rootfind(prs0(i,j,k), thl, qT, pi0(i,j,k)*th0(i,j,k))

        !CM1 dry theta additive perturbation
        tha(i,j,k) = Ta/pi0(i,j,k)

        !Perturbed water states
        rst = rslf(prs0(i,j,k), pi0(i,j,k)*th0(i,j,k)+Ta)
        if(rst.ge.qT)then
            qa(i,j,k,nqv) = qT
            qa(i,j,k,nqc) = 0.0
        else
            qa(i,j,k,nqv) = rst
            qa(i,j,k,nqc) = qT - rst
        endif

    enddo
    enddo
    enddo

    call bcu(ua)
    call bcw(wa,1)

    return

    CONTAINS

    real function N2cloudedge()

        real :: Tcld, pcld, dthlcld, dqTcld
        real :: zT, zB, dzT, dzB

        integer :: k

        k = 1
        do while(zh(1,1,k).lt.Hc)
            k = k + 1
        enddo
        
        !Cloud edge is a grid point
        if(zh(1,1,k).eq.Hc)then
            Tcld    = th0(1,1,k)*pi0(1,1,k)
            pcld    = prs0(1,1,k)
            dthlcld = log(thl0(1,1,k+1)/thl0(1,1,k-1))/(zh(1,1,k+1)-zh(1,1,k-1))
            dqTcld  = log(qv0(1,1,k+1)/(qv0(1,1,k-1)+qc0(1,1,k-1)))/(zh(1,1,k+1)-zh(1,1,k-1))

        !Cloud edge is between zh(k-1) and zh(k) interpolate values
        else
            Tcld = th0(1,1,k-1)*pi0(1,1,k-1)*(zh(1,1,k)-Hc)/(zh(1,1,k)-zh(1,1,k-1))&
                    +th0(1,1,k)*pi0(1,1,k)*(Hc-zh(1,1,k-1))/(zh(1,1,k)-zh(1,1,k-1))
            pcld = prs0(1,1,k-1)*(zh(1,1,k)-Hc)/(zh(1,1,k)-zh(1,1,k-1))&
                    +prs0(1,1,k)*(Hc-zh(1,1,k-1))/(zh(1,1,k)-zh(1,1,k-1))
            
            !Cloud edge is a half grid point
            if((zh(1,1,k+1)+zh(1,1,k-1))/2.eq.Hc)then
                dthlcld = log(thl0(1,1,k)/thl0(1,1,k-1))/(zh(1,1,k)-zh(1,1,k-1))
                dqTcld  = log(qv0(1,1,k)/(qv0(1,1,k-1)+qc0(1,1,k-1)))/(zh(1,1,k)-zh(1,1,k-1))
            else
                !calculate d/dz above and below then interpolate
                !thl
                dzT = log(thl0(1,1,k+1)/thl0(1,1,k))/(zh(1,1,k+1)-zh(1,1,k))
                dzB = log(thl0(1,1,k-1)/thl0(1,1,k-2))/(zh(1,1,k-1)-zh(1,1,k-2))
                zT  = (zh(1,1,k+1)+zh(1,1,k))/2
                zB  = (zh(1,1,k-1)+zh(1,1,k-2))/2

                dthlcld = dzB*(zT-Hc)/(zT-zB) + dzT*(Hc-zB)/(zT-zB)

                !rT
                dzT = log(qv0(1,1,k+1)/qv0(1,1,k))/(zh(1,1,k+1)-zh(1,1,k))
                dzB = log((qv0(1,1,k-1)+qc0(1,1,k-1))/(qv0(1,1,k-2)+qc0(1,1,k-2)))/(zh(1,1,k-1)-zh(1,1,k-2))

                dqTcld = dzB*(zT-Hc)/(zT-zB) + dzT*(Hc-zB)/(zT-zB)
            endif

        endif

        N2cloudedge = g*(dthlcld*dlTr_dlthl(pcld,Tcld) + dqTcld*dlTr_dlrT(pcld,Tcld))

    end function N2cloudedge

    real function dlTr_dlthl(prs,temp)
        real :: prs, temp, lamb, lambR, lambc, rtot, cptot, rst, lv_T
        real :: drl_dlthl
        
        lv_T  = lv1 - lv2*temp
        rst   = rslf(prs, temp)
        rtot  = rd + rst*rv
        cptot = cp + rst*cpv
        lambR = lv_T/rv/temp
        lambc = lv_T/cptot/temp
        lamb  = lambc*lambR*rtot/rd*rst

        drl_dlthl  = -lambR*rtot/rd*rst/(1 + lamb)

        dlTr_dlthl = 1 + drl_dlthl*(lambc - rv/rtot)
    
    end function dlTr_dlthl

    real function dlTr_dlrT(prs, temp)
        real :: prs, temp, lamb, lambR, lambc, rtot, cptot, rst, lv_T
        real :: drl_dlrT, Pterm

        lv_T  = lv1 - lv2*temp
        rst   = rslf(prs, temp)
        rtot  = rd + rst*rv
        cptot = cp + rst*cpv
        lambR = lv_T/rv/temp
        lambc = lv_T/cptot/temp
        lamb  = lambc*lambR*rtot/rd*rst

        Pterm = (Rv*cp - cpv*Rd)/(cptot**2)*rst*log(prs/p00)

        drl_dlrT  = rst*(1 - lambR*rtot/rd*Pterm)/(1 + lamb)

        dlTr_dlrT = (rv - rd)/rtot*rst/(1 + rst) + Pterm + drl_dlrT*(lambc - rv/rtot)

    end function dlTr_dlrT

    complex function eigcond(c)

        complex :: c, mb, mc

        mb = sqrt(complex(n2b,0.0)/c**2 - complex(mu**2,0.0))
        mc = sqrt(complex(mu,0.0)**2 - complex(n2c,0.0)/c**2)

        ! implement
        eigcond = tan(mb*Hc)/mb + tanh(mc*Ht)/mc
    
    end function eigcond

    real function Ta_rootfind(prs,thl,qt,Tbar)

        real :: prs, thl, qt, Tbar, Ta, Tlast, rtot, cptot, rst

        !Define R_T and (c_p)_T
        rtot  = rd + qt*rv
        cptot = cp + qt*cpv

        !Try clear air first (explicit)
        Ta = thl*(prs/p00)**(rtot/cptot) - Tbar

        !Check for consistency
        rst = rslf(prs, Tbar + Ta)

        !In cloud need nonlinear root finding
        !otherwise we're done
        IF(rst.le.qt)THEN

            Tlast = 0.0
            n = 0
            do while(abs( log(thl_func(prs, Tbar+Ta, qt)/thl) ).ge.1e-6)
                n = n+1
                if(n.ge.50) stop 1111
                Tlast = Ta
                Ta = Ta - (Tbar + Ta)*log(thl_func(prs, Tbar+Ta, qt)/thl)*dlT_dlthl(prs, Tbar+Ta)
            enddo

        ENDIF

        Ta_rootfind = Ta

    end function Ta_rootfind

    real function dlT_dlthl(prs,temp)
        real :: prs, temp, lamb, lambR, lambc, rtot, cptot, rst, lv_T
        
        lv_T  = lv1 - lv2*temp
        rst   = rslf(prs, temp)
        rtot  = rd + rst*rv
        cptot = cp + rst*cpv
        lambR = lv_T/rv/temp
        lambc = lv_T/cptot/temp
        lamb  = lambc*lambR*rtot/rd*rst

        dlT_dlthl = 1/(1+lamb)
    
    end function dlT_dlthl

    real function thl_func(prs,temp,qt)
        real :: prs, temp, qt, lambc, rtot, cptot, rst, lv_T, qv, qc

        lv_T  = lv1 - lv2*temp

        rst   = rslf(prs, temp)
        IF(rst.lt.qt)THEN
            qv = rst
            qc = qt-rst
        ELSE
            qv = qt
            qc = 0
        ENDIF

        rtot  = rd + qt*rv
        cptot = cp + qt*cpv
        lambc = lv_T/cptot/temp

        thl_func = temp*(p00/prs)**(rtot/cptot)*exp(-lambc*qc)&
                  *((rd+qv*rv)/rtot)**(rtot/cptot)*(qt/qv)**(qt*rv/cptot)

    end function thl_func

end subroutine cldoverclear_wave

!-----------------------------------------------------------------------------
!
!  subroutine template_pert: Template for perturbations from base state.
!
!  &param8 inputs :
!            var14 :
!            var15 :
!            var16 :
!            var17 :
!
!  NOTES: BLG 08 Jun 2025
!
!-----------------------------------------------------------------------------

subroutine template_pert(xh,xf,yh,yf,zh,zf,pi0,prs0,th0,thl0,&
                            qv0,qc0,rst0,u0,v0,ua,va,wa,tha,qa)

    use input
    use constants
    use cm1libs , only : rslf
    use bc_module

    implicit none

    real, dimension(ib:ie) :: xh
    real, dimension(ib:ie+1) :: xf
    real, dimension(jb:je) :: yh
    real, dimension(jb:je+1) :: yf
    real, dimension(ib:ie,jb:je,kb:ke) :: zh
    real, dimension(ib:ie,jb:je,kb:ke+1) :: zf
    real, dimension(ib:ie,jb:je,kb:ke) :: pi0,prs0,th0,qv0,qc0,t0,thl0,rst0
    real, dimension(ib:ie,jb:je,kb:ke) :: tha
    real, dimension(ibm:iem,jbm:jem,kbm:kem,numq) :: qa
    real, dimension(ib:ie+1,jb:je,kb:ke) :: u0,ua
    real, dimension(ib:ie,jb:je+1,kb:ke) :: v0,va
    real, dimension(ib:ie,jb:je,kb:ke+1) :: wa

    integer :: i,j,k,n

    ! Define Variables here

    print *, 'Generating Initial perturbation State for ...'

    !--------------------------------------!
    !          perturb winds               !
    !--------------------------------------!

    ! u is (xf,yh,zh) grid
    do k=1,nk
    do j=1,nj
    do i=1,ni+1
        !perturb u
    enddo
    enddo
    enddo

    ! v is (xh,yf,zh) grid
    do i=1,ni
    do j=1,nj+1
    do k=1,nk
        !Perturb v
    enddo
    enddo
    enddo

    ! w is (xh,yh,zf) grid
    do i=1,ni
    do j=1,nj
    do k=1,nk+1
        !Perturb w
    enddo
    enddo
    enddo

    !--------------------------------------!
    !           perturb thermo             !
    !--------------------------------------!

    do j=jb,je
    do i=ib,ie
    do k=1,ke
        ! perturb water and theta
    enddo
    enddo
    enddo

    call bcu(ua)
    call bcw(wa,1)

    return
end subroutine template_pert


END MODULE init3d_blg_module